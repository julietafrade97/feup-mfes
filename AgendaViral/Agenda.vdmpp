class Agenda

	types
		public String = seq of char;
		public MultiMap = map String to set of String;	
	
	values
	
	instance variables
	
		-- Agenda's list of categories
		public categories: set of String := {};
		
		-- Agenda's list of locations (multimap district->cities)
		public locations: MultiMap := {|->};
		
		-- Agenda's map of users
		public users: map seq of char to User := {|->};
		
		-- Agenda's list of events
		public events: set of Event := {};
		
		-- Logged in user. If nil means there is no user logged in.
		public loggedInUser: [User] := nil;
		-- TODO: depois por a private
		
	operations
		
		-- Constructor
		public Agenda: () ==> Agenda 
		Agenda() == (
			categories :=  {"Concertos", "Exposicoes", "Gastronomia", "Moda", "Desporto", "Natureza"};
			locations := {"Porto" |-> {"Porto", "Matosinhos", "Maia", "Vila Nova de Gaia"},
										"Lisboa" |-> {"Lisboa", "Amadora", "Cascais", "Sintra"},
										"Faro" |-> {"Faro", "Albufeira", "Portimao"}};	
					
			return self;
		);
		
		-- Adds user to Agenda's list of users
		public addUser: User ==> ()
		addUser(u) == users := users ++ {u.getEmail() |-> u};
		
		-- Logs the user in. Returns true if successful and updates the loggedInUser variable
		public login: String * String ==> bool
		login(email, password) == (
			dcl user: User;
			
			if (len email < 5 or len password < 8) then return false ; -- email and password not valid
			
			if (email in set dom users) then ( -- verifies if user exists
				user := users(email);
				if user.checkLogin(email, password) then ( -- verifies if password matches to email
					loggedInUser := user;
					return true;
				);
			);
			return false;
		)
		post (RESULT = true and loggedInUser <> nil) or RESULT = false;
		
		-- *ADMINISTRATOR ONLY*

		-- Adds event to Agenda's list of events
		public addEvent: Event ==> ()
		addEvent(event) == (
			events := events union {event};
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and existsCategory(event.getCategory()) and existsCity(event.getCity())
		post event in set events;
		
		-- Returns most popular events
		public mostPopularEvents: () ==> set of Event
		mostPopularEvents () == (
			dcl topEvents: set of Event := {};
			dcl temp: Event;
			dcl value: real := 0;
			dcl times: nat := 3; -- top 3
			
			while times > 0 do (
				for all event in set events do (
					if(event.getStats() > value and event not in set topEvents)
					then (
						value := event.getStats();
						temp := event;
					);
				);
				topEvents := topEvents union {temp};
				value := 0;
				times := times - 1;
			);
			
			return topEvents;
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true; -- TODO: se nao tiver pelo menos 3 eventos
		-- post topevents length ser igual a x
		
		-- *FIND EVENTS*
		
		-- Returns a set of events based on filters (excluding date)
		public findEvents: String * String * String ==> set of Event
		findEvents(city, district, category) == (
			dcl foundEvents : set of Event := {};
			
			if(city <> "")
			then foundEvents := findByCity(city)
			elseif(district <> "")
			then foundEvents := findByDistrict(district);
			
			if(category <> "")
			then (
				if city = "" and district = ""
				then foundEvents := findByCategory(category)
				else foundEvents := foundEvents inter findByCategory(category);
			);
						
			return foundEvents;	
		)
		pre loggedInUser <> nil and events <> {};
		
		-- Returns a set of events based on filters (includind date)
		public findEvents: String * String * String * Event`Date ==> set of Event
		findEvents(city, district, category, date) == (
			dcl foundEvents : set of Event := findEvents(city,district,category);
			dcl dateEvents : set of Event := {};
			
			if city = "" and district = "" and category = ""
			then foundEvents := findByDate(date) 
			else foundEvents := foundEvents inter findByDate(date);
			
			return foundEvents;	
		)
		pre loggedInUser <> nil and events <> {};
		
		
		-- by city
		public findByCity: String ==> set of Event
		findByCity(city) == (
			dcl cityEvents : set of Event := {};
			for all event in set events do (
					if event.getCity() = city
					then cityEvents := cityEvents union {event}
			);
			return cityEvents;
		)
		pre loggedInUser <> nil and existsCity(city) and events <> {};
	
		-- by district
		public findByDistrict: String ==> set of Event
		findByDistrict(district) == (
			dcl districtEvents : set of Event := {};
			for all event in set events do (
					if existsCityInDistrict(event.getCity(), district)
					then districtEvents := districtEvents union {event}
			);
			return districtEvents;
		)
		pre loggedInUser <> nil and existsDistrict(district) and events <> {};
		
		-- by category
		public findByCategory: String ==> set of Event
		findByCategory(category) == (
			dcl categoryEvents : set of Event := {};
			for all event in set events do (
					if category = event.getCategory()
					then categoryEvents := categoryEvents union {event}
			);
			return categoryEvents;
		)
		pre loggedInUser <> nil and existsCategory(category) and events <> {};
		
		-- by date
		public findByDate: Event`Date ==> set of Event
		findByDate(date) == (
			dcl dateEvents : set of Event := {};
			for all event in set events do (
					if wantedDate(date, event.getDateStart(), event.getDateEnd())
					then dateEvents := dateEvents union {event}
			);
			return dateEvents;
		)
		pre loggedInUser <> nil and events <> {};
		
		-- *AUX*
		
		-- Returns if city exists in the agenda's list of cities
		public pure existsCity: String ==> bool
		existsCity(city) == (
			dcl citiesSet : set of set of String := rng locations;
			dcl cities: set of String := {};
			for all cs in set citiesSet do(
				cities := cities union cs
			);
			return city in set cities;
		)
		pre locations <> {|->};
		
		-- Returns if district exists in the agenda's list of districts
		public pure existsDistrict: String ==> bool
		existsDistrict(district) == (
			dcl districts : set of String := dom locations;
			return district in set districts;
		)
		pre locations <> {|->};
		
		-- Returns if city exists in a certain district
		public pure existsCityInDistrict: String * String ==> bool
		existsCityInDistrict(city, district) == (
			dcl districtCities : set of String := locations(district);
			return city in set districtCities;
		)
		pre locations <> {|->};
		
		-- Returns if category exists in the agenda's list of categories
		public pure existsCategory: String ==> bool
		existsCategory(category) == (
			return category in set categories;
		)
		pre categories <> {};
		
		-- Returns if date belongs to the interval [dateStart,dateEnd]
		public pure wantedDate: Event`Date * Event`Date * Event`Date ==> bool
		wantedDate(date, dateStart,dateEnd) == (
			dcl natDateStart : nat := dateStart.year * 10000 + dateStart.month * 100 + dateStart.day;
			dcl natDateEnd : nat := dateEnd.year * 10000 + dateEnd.month * 100 + dateEnd.day;
			dcl natDate : nat := date.year * 10000 + date.month * 100 + date.day;
			
			return (natDateStart <= natDate) and (natDate <= natDateEnd);
		);
		
	functions
		
		
	traces

end Agenda