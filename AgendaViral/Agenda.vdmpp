class Agenda

	types
		public String = seq of char;
		public MultiMap = map String to set of String;	
	
	values
	
	instance variables
	
		-- Agenda's list of categories
		public categories: set of String := {};
		
		-- Agenda's list of locations (multimap district->cities)
		public locations: MultiMap := {|->};
		
		-- Agenda's map of users
		public users: map seq of char to User := {|->};
		
		-- Agenda's list of events
		public events: set of Event := {};
		
		-- Logged in user. If nil means there is no user logged in.
		public loggedInUser: [User] := nil;
		-- TODO: depois por a private
		
		-- Agenda's list of proposed events waiting for admin's approval
		public proposedEvents: set of Event := {}; 
		
	operations
		
		-- Constructor
		public Agenda: () ==> Agenda 
		Agenda() == (
			categories :=  {"Concertos", "Exposicoes", "Gastronomia", "Moda", "Desporto", "Natureza"};
			locations := {"Porto" |-> {"Porto", "Matosinhos", "Maia", "Vila Nova de Gaia"},
										"Lisboa" |-> {"Lisboa", "Amadora", "Cascais", "Sintra"},
										"Faro" |-> {"Faro", "Albufeira", "Portimao"}};	
					
			return self;
		);
		
		-- Adds user to Agenda's list of users
		public addUser: User ==> ()
		addUser(u) == users := users ++ {u.getEmail() |-> u};
		
		-- Logs the user in. Returns true if successful and updates the loggedInUser variable
		public login: String * String ==> bool
		login(email, password) == (
			dcl user: User;
			
			if (len email < 5 or len password < 8) then return false ; -- email and password not valid
			
			if (email in set dom users) then ( -- verifies if user exists
				user := users(email);
				if user.checkLogin(email, password) then ( -- verifies if password matches to email
					loggedInUser := user;
					return true;
				);
			);
			return false;
		)
		post (RESULT = true and loggedInUser <> nil) or RESULT = false;
		
		-- *ADMINISTRATOR ONLY*

		-- Adds event to Agenda's list of events
		public addEvent: Event ==> ()
		addEvent(event) == (
			events := events union {event};
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and existsCategory(event.getCategory()) and existsCity(event.getCity())
		post event in set events; -- TODO: pre evento nao pode existir com mesmo nome, cidade, categoria e datas!
		
		-- Removes event from Agenda's list of proposed events
		public rejectProposedEvent: Event ==> ()
		rejectProposedEvent(event) == proposedEvents := proposedEvents \ {event}
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and event in set proposedEvents
		post event not in set proposedEvents;
		
		-- Adds event to Agenda's list of events and removes from Agenda's list of proposed events
		public acceptProposedEvent: Event ==> ()
		acceptProposedEvent(event) == (
			events := events union {event};
			proposedEvents := proposedEvents \ {event};
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and event in set proposedEvents and event not in set events
		post event not in set proposedEvents and event in set events;
		
		-- Returns most popular event
		public mostPopularEvent: () ==> Event
		mostPopularEvent () == (
			dcl popularEvent: [Event] := nil;
			dcl value: real := 0;	

			for all event in set events do (
				if(event.getStats() >= value)
				then (
					value := event.getStats();
					popularEvent := event;
				);
			);
		
			return popularEvent;
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and events <> {};
		
		-- *REGULAR USER ONLY*
		
		-- Adds event to Agenda's list of proposed event
		public proposeEvent: Event ==> ()
		proposeEvent(event) == (
		dcl allUsers: set of User := rng users;
			for all user in set allUsers do (
				if(user.isAdmin() = true)
				then proposedEvents := proposedEvents union {event}
			);
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = false and existsCategory(event.getCategory()) and existsCity(event.getCity())
		post event in set proposedEvents; -- TODO: pre evento nao pode existir com mesmo nome, cidade, categoria e datas!
		
		-- *REGULAR ONLY*
		public buyTicket: nat * nat ==> bool
		buyTicket(eventID, nTickets) == (
			dcl eventBought : Event;
						
			for all event in set events do (
					if event.getID() = eventID
					then eventBought := event;
			);
			
			if eventBought.getTotalTickets() >= eventBought.getSoldTickets() + nTickets
			then (
				loggedInUser.buyTickets(nTickets, eventBought.getPrice());
				eventBought.buy(nTickets);
				return true;
			)
			else return false
		)
		pre loggedInUser <> nil and not loggedInUser.isAdmin()
		post RESULT = true;
		
		-- *FIND EVENTS*
		
		-- Returns a set of events based on filters
		public findEvents: String * String * String * [Event`Date] ==> set of Event
		findEvents(city, district, category, date) == (
			dcl foundEvents : set of Event := {};
			
			if city <> ""
				then foundEvents := findByCity(city)
			elseif district <> ""
				then foundEvents := findByDistrict(district);
			
			if category <> ""
			then (
				if city = "" and district = ""
				then foundEvents := findByCategory(category)
				else foundEvents := foundEvents inter findByCategory(category);
			);
			
			if date <> nil
			then (
				if city = "" and district = "" and category = ""
				then foundEvents := findByDate(date) 
				else foundEvents := foundEvents inter findByDate(date);
			);
						
			return foundEvents;	
		)
		pre loggedInUser <> nil and events <> {};
		
		-- by city
		public findByCity: String ==> set of Event
		findByCity(city) == (
			dcl cityEvents : set of Event := {};
			for all event in set events do (
					if event.getCity() = city
					then cityEvents := cityEvents union {event}
			);
			return cityEvents;
		)
		pre loggedInUser <> nil and existsCity(city) and events <> {};
	
		-- by district
		public findByDistrict: String ==> set of Event
		findByDistrict(district) == (
			dcl districtEvents : set of Event := {};
			for all event in set events do (
					if existsCityInDistrict(event.getCity(), district)
					then districtEvents := districtEvents union {event}
			);
			return districtEvents;
		)
		pre loggedInUser <> nil and existsDistrict(district) and events <> {};
		
		-- by category
		public findByCategory: String ==> set of Event
		findByCategory(category) == (
			dcl categoryEvents : set of Event := {};
			for all event in set events do (
					if category = event.getCategory()
					then categoryEvents := categoryEvents union {event}
			);
			return categoryEvents;
		)
		pre loggedInUser <> nil and existsCategory(category) and events <> {};
		
		-- by date
		public findByDate: Event`Date ==> set of Event
		findByDate(date) == (
			dcl dateEvents : set of Event := {};
			for all event in set events do (
					if wantedDate(date, event.getDateStart(), event.getDateEnd())
					then dateEvents := dateEvents union {event}
			);
			return dateEvents;
		)
		pre loggedInUser <> nil and events <> {};
		
		-- *AUX*
		
		-- Returns if city exists in the agenda's list of cities
		public pure existsCity: String ==> bool
		existsCity(city) == (
			dcl citiesSet : set of set of String := rng locations;
			dcl cities: set of String := {};
			for all cs in set citiesSet do(
				cities := cities union cs
			);
			return city in set cities;
		)
		pre locations <> {|->};
		
		-- Returns if district exists in the agenda's list of districts
		public pure existsDistrict: String ==> bool
		existsDistrict(district) == (
			dcl districts : set of String := dom locations;
			return district in set districts;
		)
		pre locations <> {|->};
		
		-- Returns if city exists in a certain district
		public pure existsCityInDistrict: String * String ==> bool
		existsCityInDistrict(city, district) == (
			dcl districtCities : set of String := locations(district);
			return city in set districtCities;
		)
		pre locations <> {|->};
		
		-- Returns if category exists in the agenda's list of categories
		public pure existsCategory: String ==> bool
		existsCategory(category) == return category in set categories
		pre categories <> {};
		
		-- Returns if date belongs to the interval [dateStart,dateEnd]
		public pure wantedDate: Event`Date * Event`Date * Event`Date ==> bool
		wantedDate(date, dateStart,dateEnd) == (
			dcl natDateStart : nat := dateStart.year * 10000 + dateStart.month * 100 + dateStart.day;
			dcl natDateEnd : nat := dateEnd.year * 10000 + dateEnd.month * 100 + dateEnd.day;
			dcl natDate : nat := date.year * 10000 + date.month * 100 + date.day;
			
			return (natDateStart <= natDate) and (natDate <= natDateEnd);
		);
		
		-- Returns if user admin exists in the agenda's list of users
		public pure existsAdmin: () ==> bool
		existsAdmin() == (
			dcl allUsers: set of User := rng users;
			for all user in set allUsers do (
				if(user.isAdmin() = true)
				then return true;
			);
			return false;
		)
		pre users <> {|->};
		
	functions
		
		
	traces

end Agenda