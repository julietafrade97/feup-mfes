class Agenda
	types
		public String = seq of char;
		public MultiMap = map String to set of String;	
	

	values
	
	instance variables
	
		-- Agenda's list of categories
		public categories: set of String := {};
		
		-- Agenda's list of locations (multimap district->cities)
		public locations: MultiMap := {|->};
		
		-- Agenda's map of users
		public users: map seq of char to User := {|->};
		
		-- Agenda's list of events
		public events: set of Event := {};
		
		-- Logged in user. If nil means there is no user logged in.
		public loggedInUser: [User] := nil;
		-- TODO: depois por a private
		
	operations
		
		-- Constructor
		public Agenda: () ==> Agenda 
		Agenda() == (
			categories :=  {"Concertos", "Exposicoes", "Literatura", "Moda", "Desporto", "Natureza"};
			locations := {"Porto" |-> {"Porto", "Matosinhos", "Maia", "Vila Nova de Gaia"},
										"Lisboa" |-> {"Lisboa", "Amadora", "Cascais", "Sintra"},
										"Coimbra" |-> {"Coimbra", "Cantanhede", "Figueira da Foz", "Lousa"}};	
					
			return self;
		);
		
		-- Add user
		public addUser: User ==> ()
		addUser(u) == users := users ++ {u.getEmail() |-> u};
		
		-- Log the user in. Returns true if successful and updates the loggedInUser variable
		public login: String * String ==> bool
		login(email, password) == (
			dcl user: User;
			
			if (len email < 5 or len password < 8) then return false ; -- email and password not valid
			
			if (email in set dom users) then ( -- verifies if user exists
				user := users(email);
				if user.checkLogin(email, password) then ( -- verifies if password matches to email
					loggedInUser := user;
					return true;
				);
			);
			return false;
		)
		post (RESULT = true and loggedInUser <> nil) or RESULT = false;
		
		-- *ADMINISTRATOR ONLY*

		-- Add event
		public addEvent: Event ==> ()
		addEvent(event) == (
			events := events union {event};
		)
		pre loggedInUser <> nil and loggedInUser.isAdmin() = true and existsCategory(event.getCategory()) and existsCity(event.getCity())
		post event in set events;
		
		-- *FIND EVENTS*
		
		-- find
		public findEvent: String * String * String ==> set of Event
		findEvent(city, district, category) == (
			dcl foundEvents : set of Event := {};
			dcl locationEvents : set of Event := {};
			dcl categoryEvents :  set of Event := {};
			
			if(city <> "")
			then locationEvents := findByCity(city)
			elseif(district <> "")
			then locationEvents := findByDistrict(district);
			
			if(category <> "")
			then categoryEvents := findByCategory(category);
			
			foundEvents := locationEvents inter categoryEvents;
			return foundEvents;	
		)
		pre loggedInUser <> nil and events <> {};
		
		-- by city
		public findByCity: String ==> set of Event
		findByCity(city) == (
			dcl cityEvents : set of Event := {};
			for all event in set events do (
					if event.getCity() = city
					then cityEvents := cityEvents union {event}
			);
			return cityEvents;
		)
		pre loggedInUser <> nil and existsCity(city) and events <> {};
	
		-- by district
		public findByDistrict: String ==> set of Event
		findByDistrict(district) == (
			dcl districtEvents : set of Event := {};
			for all event in set events do (
					if existsCityInDistrict(event.getCity(), district)
					then districtEvents := districtEvents union {event}
			);
			return districtEvents;
		)
		pre loggedInUser <> nil and existsDistrict(district) and events <> {};
		
		-- by category
		public findByCategory: String ==> set of Event
		findByCategory(category) == (
			dcl categoryEvents : set of Event := {};
			for all event in set events do (
					if category = event.getCategory()
					then categoryEvents := categoryEvents union {event}
			);
			return categoryEvents;
		)
		pre loggedInUser <> nil and existsCategory(category) and events <> {};
		
		-- by date
		public findByDate: Event`Date ==> set of Event
		findByDate(date) == (
			dcl dateEvents : set of Event := {};
			for all event in set events do (
					if wantedDate(date, event.getDateStart(), event.getDateEnd())
					then dateEvents := dateEvents union {event}
			);
			return dateEvents;
		)
		pre loggedInUser <> nil and events <> {};
		
		-- *AUX*
		
		-- Returns if city exists in the agenda's list of cities
		public pure existsCity: String ==> bool
		existsCity(city) == (
			dcl citiesSet : set of set of String := rng locations;
			dcl cities: set of String := {};
			for all cs in set citiesSet do(
				cities := cities union cs
			);
			return city in set cities;
		)
		pre locations <> {|->};
		
		-- Returns if district exists in the agenda's list of districts
		public pure existsDistrict: String ==> bool
		existsDistrict(district) == (
			dcl districts : set of String := dom locations;
			return district in set districts;
		)
		pre locations <> {|->};
		
		-- Returns if city exists in a certain district
		public pure existsCityInDistrict: String * String ==> bool
		existsCityInDistrict(city, district) == (
			dcl districtCities : set of String := locations(district);
			return city in set districtCities;
		)
		pre locations <> {|->};
		
		-- Returns if category exists in the agenda's list of categories
		public pure existsCategory: String ==> bool
		existsCategory(category) == (
			return category in set categories;
		)
		pre categories <> {};
		
		-- Returns SOMETHING
		public pure wantedDate: Event`Date * Event`Date * Event`Date ==> bool
		wantedDate(date, dateStart,dateEnd) == (
			return (dateStart.year <= date.year and date.year <= dateEnd.year) and (dateStart.month <= date.month and date.month <= dateEnd.month) and (dateStart.day <= date.day and date.day <= dateEnd.day)
		)
		
	functions
		
		
	traces

end Agenda